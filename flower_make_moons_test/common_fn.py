#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 10 14:25:15 2021

@author: relogu
"""

import tensorflow as tf
import pathlib
import matplotlib.pyplot as plt
import numpy as np
import math
import random
from sklearn import datasets

def create_keras_model():
    """Define the common keras model used.

    Returns:
        tensorflow.keras.models.Sequential: a simple two layer sequential model use for the toy dataset make_moons
    """
    initializer = tf.keras.initializers.GlorotUniform()
    return tf.keras.models.Sequential([
        tf.keras.layers.Input((2,)),
        tf.keras.layers.Dense(4, activation='tanh',
                              kernel_initializer=initializer,
                              bias_initializer='ones',),
        tf.keras.layers.Dense(2, activation='softmax',
                              kernel_initializer=initializer,
                              bias_initializer='ones',)])

def dump_learning_curve(filename: str, round: int, loss: float, accuracy: float):
    """Dump the learning curve.
    The function dumps to the file given by complete path
    (relative or absolute) the row composed by:
    filename,round,loss,accuracy
    If round == 1, the function dumps also the header:
    \"client,round,loss,accuracy\"

    Args:
        filename ([str]): path to file to dump
        round ([int]): current round of the learning
        loss ([float]): current loss of the learning
        accuracy ([float]): current accuracy of the learning
    """
    # get file path
    path_to_file = pathlib.Path(__file__).parent.absolute()
    path_to_file = path_to_file/"output"/(filename+".dat")
    # touching file
    path_to_file.touch()
    with open(path_to_file, "a") as outfile:
        # write line(s)
        if round == 1:
            print("client,round,loss,accuracy", file=outfile)
        print(filename+","+str(round)+","+str(loss)+","+str(accuracy), file=outfile)

def translate_moons(dx: float, dy: float, x):
    """Translate using the vector (dx, dy) the make_moons dataset x.
    The function will retrieve a copy of x.

    Args:
        dx (float): x-component of the translation vector
        dy (float): y-component of the translation vector
        x (ndarray of shape (n_samples, 2)): list of 2-D points generated by sklearn.datasets.make_moons()

    Returns:
        (ndarray of shape (n_samples, 2)): translated list of 2-D points generated by sklearn.datasets.make_moons()
    """
    # get a copy
    xc = x.copy()
    # check on shape
    if x.shape[1] == 2:
        # applying transformation
        xc[:, 0] = x[:, 0] + dx
        xc[:, 1] = x[:, 1] + dy
    else :
        # error msg
        raise TypeError("the input x has not the correct shape")
    return xc

def rotate_moons(theta: float, x):
    """Rotate using the angle theta the make_moons dataset x w.r.t the origin (0,0).
    The function will retrieve a copy of x.

    Args:
        theta (float): angle generator for the rotation transformation
        x (ndarray of shape (n_samples, 2)): list of 2-D points generated by sklearn.datasets.make_moons()

    Returns:
        (ndarray of shape (n_samples, 2)): rotated list of 2-D points generated by sklearn.datasets.make_moons()
    """
    # get a copy
    xc = x.copy()
    # check on shape
    if xc.shape[1] == 2:
        # applying tranformation
        xc[:, 0] = x[:, 0]*math.cos(theta) - x[:, 1]*math.sin(theta)
        xc[:, 1] = x[:, 0]*math.sin(theta) + x[:, 1]*math.cos(theta)
    else :
        # error msg
        raise TypeError("the input x has not the correct shape")
    return xc

def plot_points(x, y):
    """Plot the points x coloring them by the labels in vector y

    Args:
        x (ndarray of shape (n_samples, 2)): vector of 2-D points to plot
        y (ndarray of shape (n_samples)): vector of numerical labels
    
    Returns:
        (matplotlib.pyplot.PathCollection)
    """
    return plt.scatter(x[:, 0], x[:, 1], c=y, cmap=plt.cm.Spectral)

def plot_dec_bound(model, x):
    """Plot the decision boundaries given by model.
    The vector x is used only to set the range of the axis.

    Args:
        model (tensorflow.keras.Model): model from which get the predictions
        x (ndarray of shape (n_samples, 2)): vector of 2-D points to plot
    
    Returns:
        (matplotlib.pyplot.QuadContourSet)
    """
    # Set min and max values and give it some padding
    x_min, x_max = x[:, 0].min() - .5, x[:, 0].max() + .5
    y_min, y_max = x[:, 1].min() - .5, x[:, 1].max() + .5
    h = 0.01
    # Generate a grid of points with distance h between them
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
    # Predict the function value for the whole gid
    Z = np.argmax(model.predict(np.c_[xx.ravel(), yy.ravel()]), axis=-1)
    Z = Z.reshape(xx.shape)
    # Plot the contour and training examples
    return plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)    

def plot_client_dataset(client_id, x_train, y_train, x_test, y_test, path=None):
    """Plot and dump to a file the data samples given the specified client id and dataset.

    Args:
        client_id (str or int or cast to str): identifier for the client
        x_train (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the train set
        y_train (ndarray of shape (n_samples)): vector of numerical labels for the train set
        x_test (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the test set
        y_test (ndarray of shape (n_samples)): vector of numerical labels for the test set
    """
    # setting path for saving image
    if path is None:
        path = 'output'
    # initialize graph
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(18,9))
    ax.set_title("Data samples for the client " + str(client_id))
    ax.set_xlabel('x')
    ax.set_ylabel('Y')
    # Plot the samples
    plot_points(x_train, y_train)
    # augment test to be colored differently
    y_test = y_test+2
    plot_points(x_test, y_test)
    plt.draw()
    #plt.show(block=False)
    plt.savefig(path+'/data_client_'+str(client_id)+'.png')
    plt.close()

def plot_decision_boundary(model, x_test, y_test, client_id=None, fed_iter=None, path=None):
    """Plot the decision boundary given the predictions of the model.

    Args:
        model (tensorflow.keras.Model): model from which get the predictions
        x_test (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the train set
        y_test (ndarray of shape (n_samples)): vector of numerical labels for the train set
        client_id (str or int or cast to str, optional): identifier for the client. Defaults to None.
        fed_iter (int, optional): current federated step of building title. Defaults to None.
        path (str, optional): complete or relative path to output folder. Defaults to None.
    """
    # setting path for saving image
    if path is None:
        path = 'output'
    # initialize graph
    plt.figure(figsize=(18, 9))
    ax = plt.subplot(1, 1, 1)
    if fed_iter is None and client_id is None: ax.set_title("Final decision boundary for the test set")
    else: ax.set_title("Decision boundary for the test set at the federated round: " + str(fed_iter))
    if client_id is None: title = 'Decison boundary for aggregated model'
    else: title = 'Decison boundary for client-'+str(client_id)+' model'
    if fed_iter is not None: title += ' at iteration '+str(fed_iter)  
    ax.set_title(title)
    # plot dec boundary
    plot_dec_bound(model, x_test)
    # plot test points
    plot_points(x_test, y_test)
    plt.draw()
    #plt.show(block=False)
    # dump to a file
    if client_id is None: filename = path+'/dec_bound_nofed'
    else: filename = path+'/dec_bound_c'+str(client_id)
    if fed_iter is None: filename += '.png'
    else: filename += '_e'+str(fed_iter)+'.png'    
    plt.savefig(filename)
    plt.close()

def build_dataset(n_clients: int, total_samples: int, noise: float, seed: int=51550):
    """Build the entire dataset, to be distributed.

    Args:
        n_clients (int): number of clients onto which distribute the whole dataset
        total_samples (int): total number of sample of the whole datset
        noise (float): the amount of noise to generate the dataset
        seed (int): the seed for the generator of the dataset

    Returns:
        x (ndarray of shape (total_samples, 2)): vector of 2-D points
        y (ndarray of shape (total_samples)): vector of numerical labels
    """
    # getting the number of samples of the clients' dataset
    N_SAMPLES = int(total_samples/n_clients)
    # initializing arrays of points and labels (may be not needed)
    x = np.array(0)
    y = np.array(0)
    # set the intial seed for the RN generator
    random.seed(seed)
    # loop on clients
    for i in range(n_clients):
        # get a RN for the state of the dataset generator
        train_rand_state = random.randint(0, 100000)
        # get data points and labels
        (x_client, y_client) = datasets.make_moons(n_samples=int(N_SAMPLES),
                                                   noise=noise,
                                                   shuffle=True,
                                                   random_state=train_rand_state)
        # fill the arrays of points and labels
        if i == 0:
            x = x_client
            y = y_client
        else :
            x = np.concatenate((x, x_client), axis=0)
            y = np.concatenate((y, y_client), axis=0)       
    return x, y

def get_client_dataset(client_id: int, n_clients: int, x_tot, y_tot):
    """Get the single client dataset given the whole dataset.

    Args:
        client_id (int): identifier of the client, must be inside [0, (n_clients) - 1]
        n_clients (int): number of clients onto which the whole dataset is being distributed
        x (ndarray of shape (total_samples, 2)): vector of 2-D points
        y (ndarray of shape (total_samples)): vector of numerical labels

    Returns:
        x (ndarray of shape (single_client_samples, 2)): vector of 2-D points relative to the client
        y (ndarray of shape (single_client_samples)): vector of numerical labels relative to the client
    """
    # check on the shapes of the inputs
    if client_id >= n_clients or client_id < 0:
        msg = "the input client_id has not an allowed value, " + \
            "insert a positive value lesser than n_clients"
        raise TypeError(msg)
    if len(x_tot.shape) != 2 or x_tot.shape[1] != 2:
        msg = "the input x_tot has not the correct shape"
        raise TypeError(msg)
    if len(y_tot.shape) != 1:
        msg = "the input y_tot has not the correct shape"
        raise TypeError(msg)
    if y_tot.shape[0] != x_tot.shape[0]:
        msg = "the inputs x_tot and y_tot have not compatible shapes, " + \
            "they must represent the same number of points"
        raise TypeError(msg)
    # get the total number of samples
    n_samples = x_tot.shape[0]
    # get the number of samples for the single clients
    n_sam_client = int(n_samples/n_clients)
    # loop on clients
    for i in range(n_clients):
        # continue on wrong clients and returning the right dataset
        if i != client_id:
            continue
        else:
            return x_tot[i*n_sam_client:(i+1)*n_sam_client], y_tot[i*n_sam_client:(i+1)*n_sam_client]
