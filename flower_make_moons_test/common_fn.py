#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 10 14:25:15 2021

@author: relogu
"""

import tensorflow as tf
import pathlib
import matplotlib.pyplot as plt
import numpy as np
import math
import random
from sklearn import datasets

def create_keras_model():
    """Define the common keras model used.

    Returns:
        tensorflow.keras.models.Sequential: a simple two layer sequential model use for the toy dataset make_moons
    """
    initializer = tf.keras.initializers.GlorotUniform()
    return tf.keras.models.Sequential([
        tf.keras.layers.Input((2,)),
        tf.keras.layers.Dense(4, activation='tanh',
                              kernel_initializer=initializer,
                              bias_initializer='ones',),
        tf.keras.layers.Dense(2, activation='softmax',
                              kernel_initializer=initializer,
                              bias_initializer='ones',)])

def dump_learning_curve(filename: str, round: int, loss: float, accuracy: float):
    """Dump the learning curve.
    The function dumps to the file given by complete path
    (relative or absolute) the row composed by:
    filename,round,loss,accuracy
    If round == 1, the function dumps also the header:
    \"client,round,loss,accuracy\"

    Args:
        filename ([str]): path to file to dump
        round ([int]): current round of the learning
        loss ([float]): current loss of the learning
        accuracy ([float]): current accuracy of the learning
    """
    path_to_file = pathlib.Path(__file__).parent.absolute()
    path_to_file = str(path_to_file)+"/output/"+filename+".dat"
    
    if round == 1:
        file = open(path_to_file, "w")
        file.write("client,round,loss,accuracy\n")
    else :
        file = open(path_to_file, "a")
    file.write(filename+","+str(round)+","+str(loss)+","+str(accuracy)+"\n")
    file.close()

def translate_moons(dx: float, dy: float, x):
    """Translate using the vector (dx, dy) the make_moons dataset x.

    Args:
        dx (float): x-component of the translation vector
        dy (float): y-component of the translation vector
        x (ndarray of shape (n_samples, 2)): list of 2-D points generated by sklearn.datasets.make_moons()

    Returns:
        (ndarray of shape (n_samples, 2)): translated list of 2-D points generated by sklearn.datasets.make_moons()
    """
    if x.shape[1] == 2:
        x[:, 0] = x[:, 0] + dx
        x[:, 1] = x[:, 1] + dy
    else :
        print("x has not the correct shape")
    return x

def rotate_moons(theta: float, x):
    """Rotate using the angle theta the make_moons dataset x w.r.t the origin (0,0).

    Args:
        theta (float): angle generator for the rotation transformation
        x (ndarray of shape (n_samples, 2)): list of 2-D points generated by sklearn.datasets.make_moons()

    Returns:
        (ndarray of shape (n_samples, 2)): rotated list of 2-D points generated by sklearn.datasets.make_moons()
    """
    xc = x.copy()
    if x.shape[1] == 2:
        xc[:, 0] = x[:, 0]*math.cos(theta) - x[:, 1]*math.sin(theta)
        xc[:, 1] = x[:, 0]*math.sin(theta) + x[:, 1]*math.cos(theta)
    else :
        print("x has not the correct shape")
    return xc

def plot_points(x, y):
    """Plot the points x coloring them by the labels in vector y

    Args:
        x (ndarray of shape (n_samples, 2)): vector of 2-D points to plot
        y (ndarray of shape (n_samples)): vector of numerical labels
    
    Returns:
        (matplotlib.pyplot.PathCollection)
    """
    return plt.scatter(x[:, 0], x[:, 1], c=y, cmap=plt.cm.Spectral)

def plot_dec_bound(model, x):
    """Plot the decision boundaries given by model.
    The vector x is used only to set the range of the axis.

    Args:
        model (tensorflow.keras.Model): model from which get the predictions
        x (ndarray of shape (n_samples, 2)): vector of 2-D points to plot
    
    Returns:
        (matplotlib.pyplot.QuadContourSet)
    """
    # Set min and max values and give it some padding
    x_min, x_max = x[:, 0].min() - .5, x[:, 0].max() + .5
    y_min, y_max = x[:, 1].min() - .5, x[:, 1].max() + .5
    h = 0.01
    # Generate a grid of points with distance h between them
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
    # Predict the function value for the whole gid
    Z = np.argmax(model.predict(np.c_[xx.ravel(), yy.ravel()]), axis=-1)
    Z = Z.reshape(xx.shape)
    # Plot the contour and training examples
    return plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)    

def plot_client_dataset(client_id, x_train, y_train, x_test, y_test, path=None):
    """Plot and dump to a file the data samples given the specified client id and dataset.

    Args:
        client_id (str or int or cast to str): identifier for the client
        x_train (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the train set
        y_train (ndarray of shape (n_samples)): vector of numerical labels for the train set
        x_test (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the test set
        y_test (ndarray of shape (n_samples)): vector of numerical labels for the test set
    """
    if path is None:
        path = 'output'
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(18,9))
    ax.set_title("Data samples for the client " + str(client_id))
    ax.set_xlabel('x')
    ax.set_ylabel('Y')
    # Plot the samples
    plot_points(x_train, y_train)
    y_test = y_test+2
    plot_points(x_test, y_test)
    plt.draw()
    #plt.show(block=False)
    plt.savefig(path+'/data_client_'+str(client_id)+'.png')
    plt.close()

def plot_decision_boundary(model, x_test, y_test, client_id=None, fed_iter=None, path=None):
    """Plot the decision boundary given the predictions of the model.

    Args:
        model (tensorflow.keras.Model): model from which get the predictions
        x_test (ndarray of shape (n_samples, 2)): vector of 2-D points to plot for the train set
        y_test (ndarray of shape (n_samples)): vector of numerical labels for the train set
        client_id (str or int or cast to str, optional): identifier for the client. Defaults to None.
        fed_iter (int, optional): current federated step of building title. Defaults to None.
        path (str, optional): complete or relative path to output folder. Defaults to None.
    """
    if path is None:
        path = 'output'
    plt.figure(figsize=(18, 9))
    ax = plt.subplot(1, 1, 1)
    if fed_iter is None and client_id is None: ax.set_title("Final decision boundary for the test set")
    else: ax.set_title("Decision boundary for the test set at the federated round: " + str(fed_iter))
    if client_id is None: title = 'Decison boundary for aggregated model'
    else: title = 'Decison boundary for client-'+str(client_id)+' model'
    if fed_iter is not None: title += ' at iteration '+str(fed_iter)  
    ax.set_title(title)
    plot_dec_bound(model, x_test)
    plot_points(x_test, y_test)
    plt.draw()
    #plt.show(block=False)
    if client_id is None: filename = path+'/dec_bound_nofed'
    else: filename = path+'/dec_bound_c'+str(client_id)
    if fed_iter is None: filename += '.png'
    else: filename += '_e'+str(fed_iter)+'.png'    
    plt.savefig(filename)
    plt.close()

def build_dataset(n_clients: int, total_samples: int, noise: float):#OLD, is_translated=False, is_rotated=False):
    """Build the whole dataset, to be distributed, with the specified features."""
    N_SAMPLES = int(total_samples/n_clients)
    x=np.array(0)
    y=np.array(0)
    for i in range(n_clients):
        random.seed(i) # maybe random.seed(51550)
        train_rand_state = random.randint(0, 100000)
        (x_client, y_client) = datasets.make_moons(n_samples=int(N_SAMPLES),
                                                   noise=noise,
                                                   shuffle=True,
                                                   random_state=train_rand_state)
        ''' OLD
        if is_rotated: 
            theta = (-1 + 2*random.random())*(math.pi/10)
            x_client = rotate_moons(theta, x_client)
        if is_translated: 
            dx = 0.2*(-1 + 2*random.random())
            dy = 0.2*(-1 + 2*random.random())
            x_client = translate_moons(dx, dy, x_client)
            '''
        if i == 0:
            x = x_client
            y = y_client
        else :
            x = np.concatenate((x, x_client), axis=0)
            y = np.concatenate((y, y_client), axis=0)       
    return x, y

def get_client_dataset(client_id, n_clients: int, x_tot, y_tot):
    """Get the single client dataset given the whole dataset."""
    if len(x_tot.shape) == 2 and x_tot.shape[1] == 2 \
        and len(y_tot.shape) == 1 and y_tot.shape[0] == x_tot.shape[0]:
        n_samples = x_tot.shape[0]
        n_sam_client = int(n_samples/n_clients)
        for i in range(n_clients):
            if i != client_id:
                continue
            else:
                return x_tot[i*n_sam_client:(i+1)*n_sam_client], y_tot[i*n_sam_client:(i+1)*n_sam_client]
    else:
        print("parameters have not the correct shape")
        return [], []

